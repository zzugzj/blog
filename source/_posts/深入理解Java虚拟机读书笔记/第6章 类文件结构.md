---
title: 第6章 类文件结构
auther: gzj
tags:
  - Java虚拟机
  - 学习笔记
categories: 深入理解Java虚拟机读书笔记
description: >-
  实现语言无关性的基础仍然是虚拟机和字节码存储格式。Java虚拟机不和包括 Java在内的任何语言绑定，它只与 “Class文件”
  这种特定的二进制文件格式所关联，Class文件中包括了Java虚拟机指令集、符号表以及若干其他辅助信息。基于安全方面的考虑，Java虚拟机规范要求在Class文件中使用许多强制性的语法和结构化约束，但任一门功能性语言都可以表示为一个能被
  Java虚拟机所接受的有效的Class文件。
abbrlink: c431302c
date: 2021-01-01 22:39:13
---



### 无关性的基石

各种不同平台的Java虚拟机，以及所有平台都统一支持的程序存储格式——字节码是构成平台无关性的基石。

实现语言无关性的基础仍然是虚拟机和字节码存储格式。Java虚拟机不和包括 Java在内的任何语言绑定，它只与 “Class文件” 这种特定的二进制文件格式所关联，Class文件中包括了Java虚拟机指令集、符号表以及若干其他辅助信息。基于安全方面的考虑，Java虚拟机规范要求在Class文件中使用许多强制性的语法和结构化约束，但任一门功能性语言都可以表示为一个能被 Java虚拟机所接受的有效的Class文件。

Java语言中的各种语法、关键字、常量变量和运算符号的语义最终都会由多条字节码指令组合表达。

<img src="https://i.loli.net/2020/05/14/SkqgRdEmITLXKi4.png" alt="image-20200514144716321" style="zoom:67%;" />

### Class类文件的结构

1、Java技术能够一直保持良好的向后兼容性，Class文件结构的稳定功不可没。

2、Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。

3、Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：“无符号数”和“表”。

1. 无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节。无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。
2. 表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表，它由如下所示的数据项构成：<img src="https://i.loli.net/2020/05/14/f76n1ACqxQolXcR.png" alt="image-20200514145246191" style="zoom: 80%;" />

4、无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的**容量计数器**加若干个连续的数据项的形式，这时称这一系列连续的某一类型的数据为某一类型的**集合**。

5、Class的结构不像XML等描述语言，由于它没有任何分隔符号，所以所有的数据项，无论是顺序还是数量，甚至于数据存储的字节序（Byte Ordering，Class文件中字节序为Big-Endian）这样的细节，都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，都不允许改变。

#### 魔数与Class文件的版本

1、每个Class文件的头4个字节称为魔数（Magic Number），它的唯一作用是**确定这个文件是否为一个能被虚拟机接受的Class文件**。

2、使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动。文件格式的制定者可以自由地选择魔数值，只要这个魔数值还没有被广泛采用过同时又不会引起混淆即可。Class文件的魔数的获得很有“浪漫气息”，值为：0x**CAFEBABE**（咖啡宝贝）。

3、紧接着魔数的4个字节存储的是Class文件的**版本号**：其中第5和第6个字节是次版本号（Minor Version），第7和第8个字节是主版本号（Major Version）。

#### 常量池

1、紧接着主次版本号之后的是常量池入口，常量池可以理解为Class文件之中的资源仓库，它是Class文件结构中与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之一，同时它还是在Class文件中第一个出现的表类型数据项目。

2、由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项 u2 类型的数据，代表常量池容量计数值（constant_pool_count）。

3、与Java中语言习惯不一样的是，**这个容量计数是从1而不是0开始的**。这样做的目的在于满足后面某些指向常量池的索引值的数据在特定情况下需要表达 “**不引用任何一个常量池项目**” 的含义，这种情况就可以把索引值置为0来表示。

4、Class文件结构中**只有常量池的容量计数是从1开始**，对于其他集合类型，包括接口索引集合、字段表集合、方法表集合等的容量计数都与一般习惯相同，是从0开始的。

5、常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。

1. 字面量比较接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值等。
2. 符号引用则属于编译原理方面的概念，包括了下面三类常量：
   1. 类和接口的全限定名（Fully Qualified Name）
   2. 字段的名称和描述符（Descriptor）
   3. 方法的名称和描述符

6、Java代码在进行 Javac 编译的时候，在虚拟机加载Class文件的时候进行动态连接。也就是说，在Class文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。

7、常量池每个常量都是一个表，截至JDK13，常量表有17种不同类型的常量。

<center>常量池的项目类型</center>

|               类型               | 标志 |             描述             |
| :------------------------------: | :--: | :--------------------------: |
|        CONSTANT_Utf8_info        |  1   |      UTF-8编码的字符串       |
|      CONSTANT_Integer_info       |  3   |          整形字面量          |
|      CONSTANT_Integer_info       |  4   |         浮点型字面量         |
|        CONSTANT_Long_info        |  5   |         长整型字面量         |
|       CONSTANT_Double_info       |  6   |      双精度浮点型字面量      |
|       CONSTANT_Class_info        |  7   |      类或接口的符号引用      |
|       CONSTANT_String_info       |  8   |       字符串类型字面量       |
|      CONSTANT_Fieldref_info      |  9   |        字段的符号引用        |
|     CONSTANT_Methodref_info      |  10  |      类中方法的符号引用      |
| CONSTANT_InterfaceMethodref_info |  11  |     接口中方法的符号引用     |
|    CONSTANT_NameAndType_info     |  12  |   字段或方法的部分符号引用   |
|    CONSTANT_MethodHandle_info    |  15  |         表示方法句柄         |
|     CONSTANT_MethodType_info     |  16  |         表示方法类型         |
|       CONSTANT_Dynamc_info       |  17  |     表示一个动态计算常量     |
|   CONSTANT_InvoleDynamic_info    |  18  |    表示一个动态方法调用点    |
|       CONSTANT_Module_info       |  19  |         表示一个模块         |
|      CONSTANT_Package_info       |  20  | 表示一个模块中开发或导出的包 |

8、实例分析

![image-20200514152333270](https://i.loli.net/2020/05/14/piK8FC5j3TGWShu.png)

1. 如上图所示：Class文件的魔数值为：0xCAFEBABE。
2. 紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号(Minor Version，图中为0x0000)，第7和第8个字节是主版本号(Major Version，图中为0x0031)。
3. 常量池容量 (偏移地址：0x00000008) 为十六进制数 0x0024，即十进制的36，这就代表常量池中有35项常量，索引值范围为1～35。
4. 常量池的第一项常量的标志位 (偏移地址：0x0000000a) 是 0x07，表示这个常量属于CONSTANT_Class_info类型。
5. CONSTANT_Class_info类型的 name_index 值 (偏移地址：0x0000000b) 为0x0002，也即是指向了常量池中的第二项常量。 它的标志位 (地址：0x0000000d) 是0x01，表示这个常量属于CONSTANT_Utf8_info类型。
6. CONSTANT_Utf8_info类型的 length 值 (偏移地址：0x0000000e) 为0x000F，也就是长15字节，往后15字节正好都在1～127的ASCII码范围以内，内容为 jvm/SimpleClass。
7. 剩下的常量 (从偏移地址 0x0000001f 开始) 可以通过类似的方法计算出来。

#### 访问标志

在常量池结束之后，紧接着的两个字节代表访问标志（access_fags），这个标志用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等。

![image-20200514152704695](https://i.loli.net/2020/05/14/asLx7fBTFgpwHQm.png)

access_flags中一共有16个标志位可以使用，当前只定义了其中8个，没有使用到的标志位要求**一律为0**。在计算时将所有符合要求的标志位取出，然后做**或**得到最终结果。

#### 类索引、父类索引与接口索引集合

1、类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，而接口索引集合（interfaces）是**一组 u2 类型的数据的集合**，Class文件中由这三项数据来确定这个类的**继承关系**。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。

2、由于 Java语言不允许多重继承，所以父类索引只有一个，除了 java.lang.Object 之外，所有的 Java类都有父类，**因此除了 java.lang.Object外，所有 Java类的父类索都不为0**。

3、接口索引集合就用来描述这个类**实现了哪些接口**，这些被实现的接口将按 implements语句（如果这个类本身是一个接口，则应当是extends语句）后的接口顺序从左到右排列在接口索引集合中。

#### 字段表集合

1、字段表（field_info）用于描述接口或者类中声明的变量。**字段（field）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。**

2、一个字段可以包含的信息有：

- 字段的作用域（public、private、protected修饰符）
- 是实例变量还是类变量（static修饰符）
- 可变性（final）
- 并发可见性（volatile修饰符，是否强制从主内存读写）
- 可否被序列化（transient修饰符）
- 字段数据类型（基本类型、对象、数组）
- 字段名称

3、上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。

4、描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的void类型都用一个大写字符来表示，而对象类型则用字符 L 加对象的全限定名来表示。

![image-20200514155954253](https://i.loli.net/2020/05/14/RmIoaF7j4ZHi8pG.png)

5、对于数组类型，**每一维度**将使用一个前置的 `[` 字符来描述，如一个定义为 `java.lang.String[][]`类型的二维数组，将被记录为：`[Ljava/lang/String`，一个整型数组 `int[]` 将被记录为 `[I` 。

6、用描述符来描述方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号 () 之内。
如方法 void inc () 的描述符为 ()V
方法` java.lang.String.toString () `的描述符为` ()Ljava/lang/String`
方法` int indexOf (char[] source,int sourceOffset,int sourceCount,char[] target,int targetOffset,int targetCount,int fromlndex) `的描述符为` ([CII[CIII)I`。

7、字段表集合中不会列出从超类或者父接口中继承而来的字段，但有可能列出原本 Java 代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。
8、另外，在 Java 语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，那字段重名就是合法的。

#### 方法表集合

1、方法的定义可以通过访问标志、名称索引、描述符索引表达清楚，但方法里面的代码去哪里了？方法里的 Java代码，经过编译器编译成字节码指令后，存放在方法属性表集合中一个名为 “Code” 的属性里面。

2、与字段表集合相对应的，如果父类方法在子类中没有被重写（Override），方法表集合中就不会出现来自父类的方法信息。但同样的，有可能会出现由编译器**自动添加**的方法，最典型的便是类构造器 `<clinit>` 方法和实例构造器 `<inits>` 方法。

3、在 Java语言中，要重载（Overload）一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名。

- 特征签名就是一个方法中各个参数在常量池的字段符号引用的集合。
- Java 代码的方法特征签名只包括了方法名称、参数顺序及参数类型，即不包含返回值，因此 Java 语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载的。
- 但是在 Class 文件格式中，特征签名的范围更大一些，还包括方法返回值以及受查异常表，只要描述符不是完全一致的两个方法也可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个Class文件中的。

#### 属性表集合

1、属性表（attribute_info）在前面已经出现过数次，在Class文件、字段表、方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息。

2、与 Class 文件中其他的数据项目要求严格的顺序、长度和内容不同，属性表集合的限制稍微宽松了一些，不再要求各个属性表具有严格顺序，并且只要不与已有属性各重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。

##### Code属性

Java程序方法体里面的代码经过javac编译器处理后，最终变成字节码指令存储在Code属性内。并非所有的方法表都必须存在这个属性，譬如**接口或者抽象类**中的方法就不存在Code属性。

![image-20200514165553782](https://i.loli.net/2020/05/14/hZa1LYVOTcpMIlB.png)

1、attribute_name_index是指向CONSTANT_Utf8_info型常量的索引，此常量值固定为“Code”。attribute_length指示了属性值的长度，属性值长度固定为整个属性表长度减去6字节。

2、max_stack表示操作数栈深度的最大值。虚拟机运行的时候需要根据这个值来分配栈帧（Stack Frame）中的操作栈深度。

3、max_locals表示局部变量表所需的内存空间。单位是变量槽(Slot)，变量槽是虚拟机为局部变量分配内存所使用的最小单位。

- 对于byte、char、float、int、short、boolean 和 returnAddress 等长度不超过32位的数据类型，每个局部变量占用 1 个Slot，而double 和 long这两种64位的数据类型则需要两个Slot来存放。
- 方法参数（包括实例方法中的隐藏参数 “this”）、显式异常处理器的参数（Exception Handler Parameter，就是try-catch语句中catch块所定义的异常）、方法体中定义的局部变量都需要使用局部变量表来存放。
- 并不是在方法中用到了多少个局部变量，就把这些局部变量所占 Slot 之和作为max_locals的值，原因是局部变量表中的 Slot 可以重用，当代码执行超出一个局部变量的作用域时，这个局部变量所占的Slot可以被其他局部变量所使用，Javac 编译器会根据变量的作用域来分配 Slot 给各个变量使用，然后计算出max_locals的大小。

4、code_length 和 code 用来存储 Java 源程序编译后生成的字节码指令。code_length代表字节码长度，code是用于存储字节码指令的一系列字节流。既然叫字节码指令，那么每个指令就是一个u1类型的单字节，当虚拟机读取到 code 中的一个字节码时，就可以对应找出这个字节码代表的是什么指令，并且可以知道这条指令后面是否需要跟随参数，以及参数应当如何理解。

5、一个u1数据类型的取值范围为 0x000xFF，对应十进制的0255，也就是一共可以表达256条指令。

虽然 code_length 是一个 u4 类型的长度值，理论上最大值可以达到 2^32 - 1，但是虚拟机规范中明确限制了一个方法不允许超过 65535 条字节码指令，即它实际只使用了 u2 的长度，如果超过这个限制，Javac 编译器也会拒绝编译。

6、在字节码指令之后的是这个方法的显式异常处理表集合，异常表对于Code属性来说并不是必须存在的，它的格式如下。其中字段的含义为：如果当字节码在第 start_pc 行到第 end_pe 行之间（不含第 end_pc 行）出现了类型为 catch_type 或者其子类的异常（catch_type为指向一个CONSTANT_Class_info型常量的索引），则转到第 handler_pc 行继续处理。当 catch_type 的值为0时，代表任意异常情况都需要转向到 handler_pc 处进行处理。

![image-20200514173110412](https://i.loli.net/2020/05/14/r1RtD4NWcPOLxpd.png)

##### Exceptions属性

Exceptions 属性的作用是列举出方法中可能抛出的**受查异常**（Checked Excepitons），也就是方法描述时在 **throws** 关键字后面列举的异常。

![image-20200514180539587](https://i.loli.net/2020/05/14/hQq7jwcsWV8Dxy4.png)

Exceptions 属性中的 number_of_exceptions 项表示方法可能抛出 number_of_exceptions 种受查异常，每一种受查异常使用一个 exception_index_table 项表示，exception_index_table 是一个指向常量池中CONSTANT_Class_info 型常量的索引，代表了该受查异常的类型。

### 字节码指令简介

Java虚拟机的指令由**一个字节长度**的、代表着某种特定操作含义的数字（称为**操作码**，Opcode）以及跟随其后的**零至多个代表此操作所需参数**（称为**操作数**，Operands）而构成。由于 Java 虚拟机采用**面向操作数栈而不是寄存器**的架构，所以大多数的指令都不包含操作数，只有一个操作码。

字节码指令集是一种具有鲜明特点、优劣势都很突出的指令集架构，由于限制了 Java 虚拟机操作码的长度为**一个字节**（即0~255），这意味着指令集的操作码总数不可能超过**256条**。

#### 字节码与数据类型

在 Java 虚拟机的指令集中，大多数的指令都包含了**其操作所对应的数据类型信息**。比如iload指令用于从局部变量表中加载int型数据到操作数栈中。

Java虚拟机的指令集对于特定的操作只提供了有限的类型相关指令去支持它，换句话说，指令集将会故意被设计成非完全独立的（Java虚拟机规范中把这种特性称为 “Not Orthogonal”，即并非每种数据类型和每一种操作都有对应的指令）。有一些单独的指令可以在必要的时候用来将一些不支持的类型转换为可被支持的类型。

编译器在编译期或运行期将byte和short类型的数据带符号扩展为相应的int类型数据，将boolean和char类型数据零位扩展为相应的int类型数据。对于大多数boolean、byte、short和char类型数据操作时，实际上都是使用相应的对int类型作为运算类型来进行的。

#### 加载和存储指令

加载和存储指令用于将数据在栈帧中的**局部变量表和操作数栈之间来回传输**，这类指令包括如下内容：

- 将一个局部变量加载到操作栈：iload、iload_\<n>...
- 将一个数值从操作数栈存储到局部变量表：istore、istore_\<n>...
- 将一个常量加载到操作数栈：bipush、sipush、ldc...
- 扩充局部变量表的访问索引的指令：wide

iload_\<n>这类尖括号结尾的指令助记符实际上代表了一组指令：iload_0, iload_1, iload_2, iload_3这几条。

#### 运算指令

运算或算术指令用于**对两个操作数栈上的值进行某种特定运算**，并把结果重新存入到操作栈顶。

大体上算术指令可以分为两种：对整型数据进行运算的指令与对浮点型数据进行运算的指令，整数和浮点数在溢出和被零除的时候也有不同的表现，无论是哪种算术指令，都使用 Java 虚拟机的数据类型。由于没有直接支持byte、short、char和boolean类型的算术指令，对于这类数据的运算，应使用操作 int 类型的指令代替。

#### 类型转换指令

类型转换指令可以**将两种不同的数值类型进行相互转换**，这些转换操作一般用于实现用户代码中的显式类型转换操作，或者用来处理本节开篇所提到的字节码指令集中数据类型相关指令无法与数据类型一一对应的问题。

Java虚拟机直接支持（即转换时无需显式的转换指令）以下数值类型的宽化类型转换（Widening Numeric Conversions，即小范围类型向大范围类型的安全转换）：

- int类型到long、float或者double类型。
- long类型到float、double类型。
- float 类型到double类型。

#### 对象创建与访问指令

虽然类实例和数组都是对象，但 Java 虚拟机对类实例和数组的创建与操作使用了不同的字节码指令。对象创建后，就可以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素，这些指令如下。

- 创建类实例的指令：new。
- 创建数组的指令：newarray、anewarray、multianewarray。
- 访问类字段（static字段，或者称为类变量）和实例字段（非static字段，或者称为实例变量）的指令：getfield、putfield、getstatic、putstatic。
- 把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、daload、aaload。
- 将一个操作数栈的值存储到数组元素中的指令：bastore、castore、sastore、iastore、fastore、dastore、aastore。
- 取数组长度的指令：arraylength。
- 检查类实例类型的指令：instanceof、checkcast。

#### 操作数栈管理指令

如同操作一个普通数据结构中的堆栈那样，Java虚拟机提供了一些用于直接操作操作数栈的指令，包括：

- 将操作数栈的栈顶一个或两个元素出栈：pop、pop2。
- 复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2。
- 将栈最顶端的两个数值互换：swap。

#### 控制转移指令

控制转移指令可以让 Java 虚拟机有条件或无条件地**从指定的位置指令而不是控制转移指令的下一条指令继续执行程序**，从概念模型上理解，可以认为控制转移指令就是在有条件或无条件地修改PC寄存器的值。

对于boolean类型、byte类型、char 类型和short类型的条件分支比较操作，都是使用 int 类型的比较指令来完成，而对于long类型、float类型和double类型的条件分支比较操作，则会先执行相应类型的比较运算指令（dcmpg、dcmpl、fcmpg、fcmpl、1cmp），运算指令会返回一个整型值到操作数栈中，随后再执行 int 类型的条件分支比较操作来完成整个分支跳转。由于各种类型的比较最终都会转化为 int 类型的比较操作，int类型比较是否方便完善就显得尤为重要，所以Java虚拟机提供的int类型的条件分支指令是最为丰富和强大的。

#### 方法调用和返回指令

方法调用仅列举以下5条用于方法调用的指令：

- invokevirtual 指令用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），这也是Java语言中最常见的方法分派方式。
- invokeinterface 指令用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。
- invokespecial 指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。
- invokestatic 指令用于调用类方法（static方法）。
- invokedynamic 指令用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法
  前面4条调用指令的分派逻辑都固化在Java虚拟机内部，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。

方法调用指令与数据类型无关，而方法返回指令是根据返回值的类型区分的，包括ireturn（当返回值是boolean、byte、char、short和int类型时使用）、lreturn、freturn、dreturn和areturn，另外还有一条return指令供声明为void的方法、实例初始化方法以及类和接口的类初始化方法使用。

#### 异常处理指令

在 Java 程序中显式抛出异常的操作（throw语句）都由athrow指令来实现，除了用 throw 语句显式抛出异常情况之外，Java虚拟机规范还规定了许多运行时异常会在其他 Java 虚拟机指令检测到异常状况时自动抛出。例如，当除数为零时，虚拟机会在idiv或ldiv 指令中抛出ArithmeticException异常。而在Java虚拟机中，处理异常（catch语句）不是由字节码指令来实现的，而是采用异常表来完成的。

#### 同步指令

Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程（Monitor）来支持的。
方法级的同步是隐式的，即无须通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池的方法表结构中的 ACC_SYNCHRONIZED 访问标志得知一个方法是否声明为同步方法。当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成（无论是正常完成还是非正常完成）时释放管程。
同步一段指令集序列通常是由 Java语言中的 synchronized语句块来表示的，Java虚拟机的指令集中有monitorenter 和 monitorexit 两条指令来支持synchronized关键字的语义，正确实现synchronized关键字需要 Javac 编译器与 Java 虚拟机两者共同协作支持。

### 公有设计，私有实现

Java虚拟机规范描绘了 Java 虚拟机应有的共同程序存储格式：**Class文件格式以及字节码指令集**。这些内容与硬件、操作系统及具体的 Java 虚拟机实现之间是完全独立的，虚拟机实现者可能更愿意把它们看做是程序在各种 Java 平台实现之间互相安全地交互的手段。

一个优秀的虚拟机实现，在满足虚拟机规范的约束下对具体实现做出修改和优化也是完全可行的，并且虚拱机规范中明确鼓励实现者这样做。只要优化后Class文件依然可以被正确读取，并且包含在其中的语义能得到完整的保持，那实现者就可以选择任何方式去实现这些语义。

虚拟机实现者可以使用这种伸缩性来让 Java 虚拟机获得更高的性能、更低的内存消耗或者更好的可移植性，选择哪种特性取决于 Java 虚拟机实现的目标和关注点是什么。虚拟机实现的方式主要有以下两种：

- 将输入的 Java 虚拟机代码在加载或执行时翻译成另外一种虚拟机的指令集。
- 将输入的 Java 虚拟机代码在加载或执行时翻译成宿主CPU的本地指令集（即 JIT-代码生成技术）。