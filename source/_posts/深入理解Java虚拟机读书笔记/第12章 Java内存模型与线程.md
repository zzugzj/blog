---
title: 第12章 Java内存模型与线程
auther: gzj
tags:
  - Java虚拟机
  - 学习笔记
categories: 深入理解Java虚拟机读书笔记
description: >-
  由于计算机在运行时，大部分时间都花在了磁盘I/O、网络通信或者数据库访问上，处理器在大部分时间都处于等待其他资源的空闲状态，让计算机同时处理几项任务就说最容易想到，也是很有效的压榨手段。
abbrlink: dcd6417a
date: 2021-01-01 23:29:23
---



## 概述

由于计算机在运行时，大部分时间都花在了磁盘I/O、网络通信或者数据库访问上，处理器在大部分时间都处于等待其他资源的空闲状态，让计算机同时处理几项任务就说最容易想到，也是很有效的压榨手段。

衡量一个服务性能的好坏，每秒事务处理数(Transaction Per Second，TPS)是重要指标之一，它代表着一秒内服务端平均能响应的请请求总数，TPS值和并发能力有很密切的关系。

## 硬件的效率与一致性

现代计算机系统都有一层或多层的高速缓存来作为内存和处理器之间的缓冲，将运算需要使用的数据复制到缓存中，让计算快速进行，运算结束后从缓存同步到内存，这样处理器就不用等待缓慢的内存读写了。

但这样有了一个新的问题：缓存一致性。在多路处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存，这种系统叫共享内存多核系统。

![image-20200518223313896](https://i.loli.net/2020/05/18/jakwtmyhWT3BOGF.png)

除了增加高速缓存外，为了使处理器内部的运算单元尽量被充分使用，处理器可能对输入的代码进行乱序执行优化，处理器会将计算结果重组，保证该结果与顺序执行的结果一致，因此如果存在一个计算任务依赖另一个计算任务的中间结果，那么其顺序性不能靠代码的先后顺序来保证。与处理器的乱序优化类似，Java虚拟机的即时编译器也有指令重排序优化。

## Java内存模型

### 主内存与工作内存

Java内存模型的主要目的是定义程序中个中变量的访问规则，即关注在虚拟机中吧变量值存储到内存和从内存取出变量值的底层细节。这里说的变量包括实例字段、静态字段和构成数组对象的元素，但不包括局部变量和方法参数，因为后者是线程私有的，不存在竞争问题。

Java内存模型规定了所有变量都存储在主内存中。每条线程还有自己的工作内存，它保存了被该线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作内存中进行。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。

![image-20200519115204571](https://i.loli.net/2020/05/19/I76PQuXMJmLHdEe.png)

### 内存间交互操作

关于一个变量如何从主内存拷贝到工作内存又如何从工作内存同步回主内存这一类的实现细节，Java内存模型定义了以下8种操作。Java虚拟机实现时必须保证下面的操作都是原子的：

- lock(锁定)：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。
- unlock(解锁)：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
- read(读取)：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。
- load(载入)：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
- use(使用)：作用于工作内存的变量，它把工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时会执行这个操作。
- assign(赋值)：作用于工作内存的变量，它会把一个执行引擎接收的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
- store(存储)：作用于工作内存的变量，它把工作内存中的一个变量的值传送给主内存中，以便随后的write操作使用。
- write(写入)：作用于主内存的变量，它把store操作从工作内存得到的变量的值放入主内存的变量中。

如果要把一个变量从主内存拷贝到工作内存，那就要按顺序执行read和load操作，如果要把变量从工作内存同步回主内存，就要按顺序执行store和write操作。Java内存模型要求上述操作按顺序执行，但不要钱连续执行，也就是read和load操作间可以有别的指令。如对变量a、b进行访问时，一种可能出现的顺序就是read a、read b、load b、load a。

Java内存模型还规定了在执行上述8中基本操作时必须满足的规则：

- 不允许read和load、store和write操作之一单独出现，即不允许加载或同步工作到一半。
- 不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后，必须把改变化同步回主内存。
- 不允许一个线程无原因地（无assign操作）把数据从工作内存同步到主内存中。
- 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未初始化(load或assign)的变量。
- 一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次lock之后必须要执行相同次数的unlock操作，变量才会解锁。
- 如果对一个对象进行lock操作，那会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。
- 如果一个变量事先没有被lock，就不允许对它进行unlock操作，也不允许去unlock一个被其他线程锁住的变量。
- 对一个变量执行unlock操作之前，必须将此变量同步回主内存中（执行store、write）。

有如上8种内存访问操作以及规则限定，再加上对volatile的一些特殊规定，就已经完全确定了java程序中哪些内存访问操作是在并发下安全的。

### 对于volatile型变量的特殊规则

关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制。

当一个变量被定义为volatile后，它将具备两个特性：第一个就是保证此变量对所有线程的可见性，就是指一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量需要通过主内存完成线程间的传递；第二个就是禁止指令重排序优化，重排序优化是机器级的操作，也就是硬件级别的操作。重排序会打乱代码顺序执行，但会保证在执行过程中所有依赖赋值结果的地方都能获取到正确的结果，因此在一个线程的方法执行过程中无法感知到重排的操作影响，这也是“线程内表现为串行”的由来。

![image-20200519182215684](https://i.loli.net/2020/05/19/wcyqszaFiJu9lh5.png)

编译后，这段代码对instance变量赋值部分如下图所示：

![image-20200519182250093.png](https://i.loli.net/2020/05/19/4QG79OV8FLRpYoJ.png)

其实，有volatile修饰的变量，赋值后(mov %eax, 0x150(%esi))多执行了一个"lock addl $0x0, (%esp)"操作，这个操作相当于一个内存屏障：指令重排序时，不能把后面的指令重排序到内存屏障之前。

另外，java内存模型对volatile变量有三条特殊规则：

- 每次使用变量之前都必须先从主内存刷新最新的值，用于保证能看见其它线程对变量的修改；

- 每次对变量修改后都必须立刻同步到主内存中，用于保证其它线程可以看到自己的修改；

- 两个变量都是volatile的，将数据同步到内存的时候，先读的先写；

性能上，volatile同步机制的性能优于锁，读操作上性能消耗和普通变量没什么区别，但写操作可能慢一些，因为它需要在本地代码插入许多内存屏障指令来保证处理器不发生乱序执行。

### 针对long和double型变量的特殊规则

Java内存模型要求lock、unlock、read、load、assign、use、store、write都具有原子性，但对于64位的数据类型(long和double)，定义了比较宽松的规定：允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作进行，即允许虚拟机实现自行选择是否要保证64位数据类型的load、store、read、write操作的原子性。

### 原子性、可见性与有序性

**原子性**

我们大致可以认为基本数据类型的访问读写具备原子性的(long、double除外，无需该在意)。

如果应用场景需要更大范围的原子性保证，Java内存模型还提供了lock、unlock操作来满足这个需求。虽然虚拟机没有把这两个操作直接开放给用户，但是提供了更高层次的字节码指令monitorenter和monitorexit，这两个字节码指令反映到Java代码中就是同步块。synchronized，因此同步块中的操作具备原子性的。

**可见性**

指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。volatile保证了多线程操作时变量的可见性，普通变量则不能保证这一点。

除了volatile外，Java还有两个关键字能实现可见性：synchronized和final。

同步块的可见性是因为：对一个变量执行unlock前，必须先把此变量同步回主内存中。final的可见性是：被final修饰的字段在构造器中一旦初始化完成，那么在其他线程中就能看到final字段的值。

**有序性**

如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是"线程内表现为串行的语义"，后半句是"指令重排序"和"工作内存与主内存同步延迟"。

Java提供volatile和synchronized关键字来保证线程之间操作的有序性，volatile本身包含了禁止指令重排序优化的语义，而synchronized是因为"一个变量在同一时刻只允许一条线程对其进行lock操作"。

### 先行发生原则

如果Java内存模型的有序性只靠volatile和synchronized完成，那么有一些操作会很繁琐，所以，Java中有一个"先行发生"的原则。

先行发生是Java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，也就是说发生操作B之前，操作A产生的影响能被操作B观察到，"影响"包括修改了内存中共享变量的值、发送了消息、调用了方法等。

Java内存模型中的一些内置的先行发生关系：

- 程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。
- 管程锁定规则：一个unlock操作先行发生与后面对同一个锁的lock操作。
- volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量对读操作。
- 线程启动规则：Thread对象对start()方法先行发生于此线程的每一个动作。
- 线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止。
- 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生。
- 对象终结规则：一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始。
- 传递性：如果操作A先行发生于操作B，操作B先行发生于操作C，那么操作A就先行发生于操作C。

## Java与线程

### 线程的实现

线程是比进程更轻量级的调度执行单位，线程的引入，可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源(内存地址、文件I/O等)，又可以独立调度(线程是CPU调度的基本单位)。

实现线程主要有3种方式：

1.使用内核线程实现

内核线程(Kernel-Level Thread，KLT)就是直接由操作系统内核(Kernel)支持的线程，这种线程由内核完成线程切换，内核通过操纵调度器对线程进行调度，并负责将心线程的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身，这样操作系统就有能力同时处理多件事情，支持多线程的内核叫做多线程内核。

程序一般不会直接使用内核线程，而去使用内核线程的一种高级接口——轻量级进程(Light Weight Process，LWP)，轻量级进程就是我们所说的"线程"，每个轻量级进程都由一个内核线程支持，轻量级进程与内核线程之间1:1的关系称为一对一的线程模型。

由于内核线程的支持，每个轻量级进程都称为一个独立的调度单元，即使有一个轻量级进程在系统调用中阻塞了，也不会影响整个进程继续工作，但是轻量级进程具有它的局限性：由于基于内核线程实现的，所以各种线程操作(创建、析构、同步)都需要进行系统调用。而系统调用的代价相对较高，需要在用户态(User Mode)和内核态(Kernel Mode)中来回切换；再一个就是每个轻量级进程都需要一个内核线程的支持，因此轻量级进程要消耗一定的内核资源(如内核线程的栈空间)，因此一个系统支持轻量进程的数量是有限的。

2.使用用户线程实现

广义上说，一个线程只要不是内核线程，就可以认为是用户线程(User Thread，UT)。所以，这么看的话，轻量级进程也属于用户线程，但轻量级进程的实现始终是建立在内核上的，许多操作都要进行系统调用，效率收到限制。

狭义上的用户线程指完全建立在用户空间的线程库上，用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核帮助。这种线程不需要切换到内核态，因此操作可以非常快速且低耗，支持规模更大的线程数。

用户线程优势在于不需要系统内核支援，劣势也是在于没有系统内核支援。线程的创建、切换和调度都是需要考虑的问题，由于操作系统只把处理器资源分配到进程，如"阻塞如何处理"、"多处理器系统中如何将线程映射到其他处理器上"这类问题解决异常困难。现在使用用户线程的程序越来越少了，Java、Ruby等都曾使用过，但最后都放弃了。

3.使用用户线程+轻量级进程混合实现

这种混合实现下，既存在用户线程，也存在轻量级进程。用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且支持大规模的用户线程并发；操作系统提供支持的轻量级进程作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用通过轻量级进程线程完成，大大降低了整个进程被完全阻塞的风险。

4.Java线程的实现

操作系统支持怎样的线程模型，很大程度上会影响上面 Java虚拟机的线程是怎样映射的，这一点在不同平台上很难达成一致，因此《Java虚拟机规范》中没有限定Java线程需要使用那种线程模型来实现。

### Java线程调度

线程调度是系统为线程分配处理器使用权的过程，调度主要方式有两种，分别是协同式线程调度和抢占式线程调度。

协同式调度的多线程系统

- 线程的执行时间由线程本身控制，线程把自己的工作执行完后，主动通知系统切换到另一个线程上。由于线程把自己的事情做完后才会进行线程切换，所以没什么线程同步的问题。

  缺点：线程执行时间不可由控制。如果一个线程有问题，一直不告知系统进行线程切换，那么程序就一直阻塞在那。

抢占式调度的多线程系统

- 每个线程由系统分配执行时间，线程的切换不由线程本身决定(Java中，Thread.yield()方法可以让出执行时间，但要获取执行时间，线程本身是没有办法的)。

  这种实现方式下，线程的执行时间是系统可控的 ，也不会由一个线程导致整个进程阻塞的问题，Java的线程调度就是抢占式调度。

Java中虽然线程调度是系统完成的，但是我们可以使系统给某些进程多分配一些时间，另外的线程少分配一些。这项操作通过设置线程优先级来完成：Java中一共有10个级别的线程优先级，在两个线程同时Ready状态时，优先级越高的线程越容易被系统选择执行。

但线程优先级不稳定，优先级可能被系统自行改变，当系统发现一个线程执行很频繁时，可能会越过线程优先级去为他分配执行时间，从而减少线程频繁切换带来的性能消耗。

### 状态转换

Java语言定义了6种线程状态，在任意一个时间点，一个线程有且只有其中一种状态：

- 新建(New)：创建后尚未启动的线程处于这种状态。
- 运行(Runable)：Runable包括了操作系统线程状态中的Running和Ready。(也就是处于此状态的线程可能正在执行，也可能正在等待着CPU为它分配时间执行)。
- 无限期等待(Waiting)：处于这种状态的线程不会被分配CPU执行时间，它们要等待被其他线程显示唤醒。以下方法会让线程进入无限期的等待：
  - 没有设置Timeout参数的Object.wait()方法
  - 没有设置Timeout参数的Thread.join()方法
  - LockSupport.park()方法

- 限期等待(Timed Waiting)：处于这种状态的线程也不会被分配CPU时间，在一定时间后它们由系统自动唤醒。以下方法让线程进入限期等待：
  - Thread.sleep()
  - 设置了Timeout参数的Object.wait()方法
  - 设置了Timeout参数的Thread.join()方法
  - LockSupport.parkNanos()
  - LockSupport.parkUntil()

- 阻塞(Blocked)：线程被阻塞。"阻塞状态"与"等待状态"的区别是："阻塞状态"在等待着获取一个排它锁，这个时间将在另一个线程放弃这个锁的时候发生；"等待状态"是等待一段时间或唤醒的动作发生。
- 结束(Terminated)：已终止线程的状态，线程结束执行。

![image-20200519212052995](https://i.loli.net/2020/05/19/5zG7eBvQkTgNfMJ.png)

### Java与协程

内核线程调度成本比较高昂，因为要进行响应中断，保护和恢复执行现场。当中断发生，线程A切换到线程B前，操作系统首先要把线程A的上下文数据妥善保护好，然后把寄存器、内存分页等恢复到线程B挂起时候的状态，这样线程B被重新激活后才能仿佛没有被挂起过。

协程的主要优势是轻量，无论有栈协程还是无栈协程，都比传统内核线程轻量的多。不设置-Xss或-XX:ThreadStackSize，则在64位Linux上HotSpot的线程栈容量是1MB，但一个协程的栈通常在几百字节到几KB之间。

但在Java语言上，比如HotSpot虚拟机，Java调用栈和本地调用栈是做在一起的，在协程中调用本地方法的话，切换协程可能影响整个线程，在这里，以后将会有一种叫纤程的东西来解决。Loom以后将会实现。