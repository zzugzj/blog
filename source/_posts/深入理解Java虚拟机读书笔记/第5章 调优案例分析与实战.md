---
title: 第5章 调优案例分析与实战
auther: gzj
tags:
  - Java虚拟机
  - 学习笔记
categories: 深入理解Java虚拟机读书笔记
description: >-
  监控服务器运行状况后发现网站响应是有GC停顿导致的，虚拟机运行在Server模式，默认使用吞吐量优先收集器，由于程序设计的问题，访问文档要把文档从磁盘
  提取到内存中，导致内存中出现很多有文档序列化产生的大对象，并且这些大对象都进入老年代。
abbrlink: 20e6ef96
date: 2021-01-01 21:42:13
---



### 案例分析

#### 高性能硬件上的程序部署

**两种方式**

> 通过64位JDK使用大内存

内存回收导致长时间停顿。

现阶段，64位JDK的性能结果普遍低于32位JDK。

需要保证程序稳定，因为产生堆栈溢出几乎无法产生堆转储快照，产生了也无法分析。

由于指针膨胀、数据类型对齐补白等因素，64位消耗内存更大。

> 通过若干个32位虚拟机建立逻辑集群来利用硬件资源

避免节点竞争全局资源，例如磁盘竞争。

很难最高效率的利用某些资源池。

各节点不可避免的受到32G的内存限制。

大量使用本地缓存的应用，造成内存浪费，考虑改为集中式缓存。

#### 堆外内存导致的溢出错误

除了Java堆和方法区之外，一下区域还可能占用较多内存：

- 直接内存：可通过-XX:MaxDirectMemorySize调整大小，内存不足时抛出OutOfMemoryError或者OutOfMemoryError:Direct buffer memory
- 线程堆栈：可通过-Xss调整大小，内存不足时抛出StackOverFlowError(如果线程请求的栈深度大于虚拟机允许的深度)或者OutOfMemoryError(如果Java虚拟机栈容量可以动态扩展，当栈扩展无法申请到足够的内存)。
- Socket缓存区：每个Socket连接都Receive和Send两个缓存区，分别占用约37KB和25KB内存，连接多的话这块内存占用也可观。如果无法分配，可能会抛出IOException:Too many open files异常。
- JNI代码：如果代码中使用了JNI调用本地库，那本地库使用的内存也不在堆中，而是占用Java虚拟机的本地方法栈和本地内存的。
- 虚拟机和垃圾收集器：虚拟机、垃圾收集器的工作也是要消耗一定数量的内存的。

